# Example Output: GPIO Control on Jetson Orin
## Generated by Multi-Agent Learning System

---

## Agent Coordination Log

```yaml
module_id: "MOD-GPIO-001"
creation_date: "2024-01-15"
agents_involved:
  - curriculum_designer: "Structured learning path"
  - documentation_researcher: "NVIDIA docs, kernel sources"
  - code_generator: "BitBake recipes, kernel modules"
  - tutorial_builder: "Step-by-step guide"
  - testing_validation: "Hardware verification"
  - project_architect: "Real-world application"
```

---

## 1. Research Papers & Documentation
*Generated by Documentation Researcher Agent*

### Essential Reading List

#### Primary Sources
1. **NVIDIA Jetson Linux Developer Guide** (v35.5.0)
   - Chapter 12: GPIO Programming
   - Chapter 15: Device Tree Customization
   - Appendix B: Pinmux Configuration

2. **Linux Kernel GPIO Subsystem Documentation**
   - Documentation/gpio/consumer.rst
   - Documentation/devicetree/bindings/gpio/

3. **Meta-tegra Layer Documentation**
   - GPIO configuration in machine configs
   - Kernel recipe customization

#### Research Papers
1. *"Real-time GPIO Control in Embedded Linux Systems"* (2023)
   - Key insight: Interrupt-driven vs polling trade-offs
   - Relevance: Performance optimization for Jetson

2. *"Hardware Abstraction Layers in Modern SoCs"* (2024)
   - Key insight: Multi-layer GPIO abstraction
   - Relevance: Understanding Tegra GPIO architecture

### Key Concepts Summary
- **Tegra GPIO Banks**: Understanding PQ.06 notation
- **Pinmux vs GPIO**: Two-layer configuration model
- **sysfs vs libgpiod**: Modern GPIO interfaces
- **Device Tree Overlays**: Runtime reconfiguration

---

## 2. Python Tools & Models
*Generated by Code Generator Agent*

### Tool 1: GPIO Calculator

```python
#!/usr/bin/env python3
"""
gpio_calculator.py - Convert between Jetson GPIO naming schemes
Generated for Orin AGX platform
"""

import argparse
from dataclasses import dataclass
from typing import Optional

@dataclass
class GpioMapping:
    """Maps between different GPIO naming conventions"""
    tegra_name: str  # e.g., "PQ.06"
    linux_gpio: int   # e.g., 454
    header_pin: Optional[int]  # 40-pin header position
    ball_name: str  # Package ball identifier
    signal_name: str  # Carrier board signal

class JetsonGpioCalculator:
    """Convert between Jetson GPIO naming schemes"""
    
    # Orin AGX GPIO port bases
    PORT_BASES = {
        'PA': 316, 'PB': 324, 'PC': 332, 'PD': 340,
        'PE': 348, 'PF': 356, 'PG': 364, 'PH': 372,
        'PI': 380, 'PJ': 388, 'PK': 396, 'PL': 404,
        'PM': 412, 'PN': 420, 'PO': 428, 'PP': 436,
        'PQ': 443, 'PR': 451, 'PS': 459, 'PT': 467,
        'PU': 475, 'PV': 483, 'PW': 491, 'PX': 499,
        'PY': 507, 'PZ': 515, 'PAA': 523, 'PAB': 531,
        'PAC': 539, 'PAD': 547, 'PAE': 555, 'PAF': 563,
        'PAG': 571
    }
    
    def tegra_to_linux(self, tegra_name: str) -> int:
        """
        Convert Tegra GPIO name to Linux GPIO number
        Example: 'PQ.06' -> 454
        """
        parts = tegra_name.split('.')
        if len(parts) != 2:
            raise ValueError(f"Invalid Tegra GPIO format: {tegra_name}")
        
        port = parts[0]
        pin = int(parts[1])
        
        if port not in self.PORT_BASES:
            raise ValueError(f"Unknown GPIO port: {port}")
        
        return self.PORT_BASES[port] + pin
    
    def linux_to_tegra(self, gpio_num: int) -> str:
        """
        Convert Linux GPIO number to Tegra name
        Example: 454 -> 'PQ.06'
        """
        for port, base in self.PORT_BASES.items():
            if base <= gpio_num < base + 8:
                pin = gpio_num - base
                return f"{port}.{pin:02d}"
        
        raise ValueError(f"GPIO {gpio_num} not in valid range")
    
    def validate_for_userspace(self, gpio_num: int) -> bool:
        """Check if GPIO is accessible from userspace"""
        restricted_ranges = [
            (316, 324),  # Reserved for boot
            (500, 508),  # Used by display controller
        ]
        
        for start, end in restricted_ranges:
            if start <= gpio_num < end:
                return False
        return True

def main():
    parser = argparse.ArgumentParser(description='Jetson GPIO Calculator')
    parser.add_argument('--tegra', help='Convert from Tegra name (e.g., PQ.06)')
    parser.add_argument('--linux', type=int, help='Convert from Linux GPIO number')
    parser.add_argument('--validate', type=int, help='Validate GPIO for userspace')
    
    args = parser.parse_args()
    calc = JetsonGpioCalculator()
    
    if args.tegra:
        gpio = calc.tegra_to_linux(args.tegra)
        print(f"Tegra {args.tegra} = Linux GPIO {gpio}")
        print(f"Export command: echo {gpio} > /sys/class/gpio/export")
        
    elif args.linux:
        tegra = calc.linux_to_tegra(args.linux)
        print(f"Linux GPIO {args.linux} = Tegra {tegra}")
        
    elif args.validate:
        valid = calc.validate_for_userspace(args.validate)
        status = "accessible" if valid else "restricted"
        print(f"GPIO {args.validate} is {status} from userspace")

if __name__ == "__main__":
    main()
```

### Tool 2: BitBake Recipe Generator

```python
#!/usr/bin/env python3
"""
recipe_generator.py - Generate Yocto recipes for GPIO drivers
"""

import json
from pathlib import Path
from typing import Dict, List

class GpioRecipeGenerator:
    """Generate BitBake recipes for GPIO kernel modules"""
    
    TEMPLATE = '''SUMMARY = "{summary}"
DESCRIPTION = "{description}"
LICENSE = "GPLv2"
LIC_FILES_CHKSUM = "file://COPYING;md5=d7810fab7487fb0aad327b76f1be7cd7"

inherit module

SRC_URI = "file://Makefile \\
           file://{module_name}.c \\
           file://COPYING"

S = "${{WORKDIR}}"

KERNEL_MODULE_AUTOLOAD += "{module_name}"
KERNEL_MODULE_PROBECONF += "{module_name}"

# Jetson Orin specific configuration
COMPATIBLE_MACHINE = "(tegra234|orin)"

do_compile() {{
    oe_runmake KERNELDIR=${{STAGING_KERNEL_DIR}} \\
               ARCH=${{ARCH}} \\
               CC="${{KERNEL_CC}}" \\
               LD="${{KERNEL_LD}}"
}}

do_install() {{
    install -d ${{D}}${{nonarch_base_libdir}}/modules/${{KERNEL_VERSION}}/extra
    install -m 0644 ${{S}}/{module_name}.ko \\
            ${{D}}${{nonarch_base_libdir}}/modules/${{KERNEL_VERSION}}/extra/
}}

# Runtime dependencies
RDEPENDS:${{PN}} = "kernel-module-gpio-tegra234"
'''
    
    def generate_recipe(self, config: Dict) -> str:
        """Generate a complete BitBake recipe"""
        return self.TEMPLATE.format(**config)
    
    def generate_kernel_module(self, gpio_config: Dict) -> str:
        """Generate kernel module source code"""
        return f'''/* {gpio_config['module_name']}.c - GPIO driver for Jetson Orin */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/gpio.h>
#include <linux/interrupt.h>
#include <linux/platform_device.h>

#define GPIO_PIN {gpio_config['gpio_pin']}
#define DRIVER_NAME "{gpio_config['module_name']}"

static int gpio_irq;

static irqreturn_t gpio_irq_handler(int irq, void *dev_id)
{{
    pr_info("%s: GPIO interrupt triggered\\n", DRIVER_NAME);
    return IRQ_HANDLED;
}}

static int __init gpio_driver_init(void)
{{
    int ret;
    
    ret = gpio_request(GPIO_PIN, DRIVER_NAME);
    if (ret) {{
        pr_err("Failed to request GPIO %d\\n", GPIO_PIN);
        return ret;
    }}
    
    gpio_direction_input(GPIO_PIN);
    
    gpio_irq = gpio_to_irq(GPIO_PIN);
    ret = request_irq(gpio_irq, gpio_irq_handler,
                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                      DRIVER_NAME, NULL);
    
    if (ret) {{
        pr_err("Failed to request IRQ\\n");
        gpio_free(GPIO_PIN);
        return ret;
    }}
    
    pr_info("%s: Initialized for GPIO %d\\n", DRIVER_NAME, GPIO_PIN);
    return 0;
}}

static void __exit gpio_driver_exit(void)
{{
    free_irq(gpio_irq, NULL);
    gpio_free(GPIO_PIN);
    pr_info("%s: Unloaded\\n", DRIVER_NAME);
}}

module_init(gpio_driver_init);
module_exit(gpio_driver_exit);

MODULE_LICENSE("GPL v2");
MODULE_AUTHOR("Learning System");
MODULE_DESCRIPTION("GPIO driver for Jetson Orin");
'''
```

---

## 3. Step-by-Step Tutorial
*Generated by Tutorial Builder Agent*

### Lab 1: Basic GPIO Control via sysfs

#### Prerequisites
✅ Jetson Orin AGX with JetPack 5.1+  
✅ SSH access to the board  
✅ Multimeter or LED for testing  

#### Learning Objectives
After completing this lab, you will be able to:
- Export and control GPIOs via sysfs
- Convert between GPIO naming schemes
- Handle GPIO permissions properly
- Debug common GPIO issues

#### Step 1: Understanding GPIO Mapping

First, let's identify which GPIO we'll use. We'll work with pin 31 on the 40-pin header, which maps to `PQ.05`:

```bash
# SSH into your Jetson Orin
ssh user@jetson-orin.local

# Check current GPIO allocations
sudo cat /sys/kernel/debug/gpio
```

Expected output:
```
gpiochip0: GPIOs 316-511, parent: platform/c2f0000.gpio, tegra234-gpio:
 gpio-348 (PE.04               |force-recovery      ) in  hi 
 gpio-389 (PJ.05               |vdd-3v3-sys         ) out lo 
 gpio-448 (PQ.05               |unused              ) 
```

#### Step 2: Export and Configure GPIO

```bash
# Calculate Linux GPIO number for PQ.05
# PQ base = 443, pin 5 = 443 + 5 = 448

# Export the GPIO
echo 448 | sudo tee /sys/class/gpio/export

# Set direction to output
echo out | sudo tee /sys/class/gpio/gpio448/direction

# Control the GPIO
echo 1 | sudo tee /sys/class/gpio/gpio448/value  # High
echo 0 | sudo tee /sys/class/gpio/gpio448/value  # Low

# Read back the value
cat /sys/class/gpio/gpio448/value
```

#### Step 3: Create a Python Control Script

```python
#!/usr/bin/env python3
# gpio_blink.py - Blink an LED on GPIO

import time
import os

class JetsonGPIO:
    def __init__(self, gpio_num):
        self.gpio_num = gpio_num
        self.gpio_path = f"/sys/class/gpio/gpio{gpio_num}"
        
    def export(self):
        """Export GPIO to userspace"""
        if not os.path.exists(self.gpio_path):
            with open("/sys/class/gpio/export", "w") as f:
                f.write(str(self.gpio_num))
            time.sleep(0.1)  # Wait for sysfs
    
    def set_direction(self, direction):
        """Set GPIO direction (in/out)"""
        with open(f"{self.gpio_path}/direction", "w") as f:
            f.write(direction)
    
    def write(self, value):
        """Write GPIO value (0/1)"""
        with open(f"{self.gpio_path}/value", "w") as f:
            f.write(str(value))
    
    def read(self):
        """Read GPIO value"""
        with open(f"{self.gpio_path}/value", "r") as f:
            return int(f.read().strip())
    
    def cleanup(self):
        """Unexport GPIO"""
        with open("/sys/class/gpio/unexport", "w") as f:
            f.write(str(self.gpio_num))

# Blink LED example
gpio = JetsonGPIO(448)  # PQ.05
gpio.export()
gpio.set_direction("out")

try:
    for i in range(10):
        gpio.write(1)
        print(f"LED ON  - Iteration {i+1}/10")
        time.sleep(0.5)
        
        gpio.write(0)
        print(f"LED OFF - Iteration {i+1}/10")
        time.sleep(0.5)
finally:
    gpio.cleanup()
    print("GPIO cleaned up")
```

#### Troubleshooting Common Issues

##### Issue 1: Permission Denied
**Symptom**: `Permission denied` when accessing `/sys/class/gpio`

**Solution**:
```bash
# Add user to gpio group
sudo usermod -aG gpio $USER
# Logout and login again

# Or create udev rule
echo 'SUBSYSTEM=="gpio", MODE="0666"' | sudo tee /etc/udev/rules.d/99-gpio.rules
sudo udevadm control --reload-rules
```

##### Issue 2: GPIO Already Exported
**Symptom**: `Device or resource busy`

**Solution**:
```bash
# Check what's using the GPIO
sudo lsof | grep gpio448
# Unexport if needed
echo 448 | sudo tee /sys/class/gpio/unexport
```

##### Issue 3: GPIO Doesn't Toggle
**Symptom**: Value stays at 0 or 1

**Solution**:
```bash
# Check pinmux configuration
sudo /opt/nvidia/jetson-io/jetson-io.py

# Verify device tree
sudo dtc -I fs -O dts /proc/device-tree | grep -A5 "gpio@c2f0000"
```

#### Verification Checklist
- [ ] GPIO exports without errors
- [ ] Can set direction (in/out)
- [ ] Value changes when written
- [ ] LED/multimeter confirms hardware response
- [ ] Python script runs successfully
- [ ] Cleanup unexports GPIO properly

---

## 4. Real-World Project
*Generated by Project Architect Agent*

### Project: Smart Sensor Hub with GPIO Interrupts

#### Overview
Build a multi-sensor monitoring system using Jetson Orin's GPIO capabilities, featuring interrupt-driven sensor reading, real-time data processing, and cloud connectivity.

#### Architecture

```
┌─────────────────┐
│  Cloud Backend  │
└────────▲────────┘
         │ MQTT
┌────────┴────────┐
│  Jetson Orin    │
├─────────────────┤
│ - GPIO Manager  │
│ - Sensor Drivers│
│ - Edge AI       │
│ - Data Pipeline │
└────────┬────────┘
         │ GPIO/I2C
┌────────▼────────┐
│    Sensors      │
├─────────────────┤
│ - Motion (GPIO) │
│ - Temp (I2C)    │
│ - Light (ADC)   │
└─────────────────┘
```

#### Implementation Phases

##### Phase 1: GPIO Interrupt Handler
```c
// sensor_hub.c - Kernel module for sensor interrupts

#include <linux/interrupt.h>
#include <linux/gpio.h>
#include <linux/kfifo.h>

#define MOTION_GPIO 448  // PQ.05
#define FIFO_SIZE 1024

static DECLARE_KFIFO(sensor_fifo, struct sensor_event, FIFO_SIZE);

struct sensor_event {
    u64 timestamp;
    u8 sensor_id;
    u32 value;
};

static irqreturn_t motion_isr(int irq, void *data)
{
    struct sensor_event event = {
        .timestamp = ktime_get_ns(),
        .sensor_id = MOTION_SENSOR_ID,
        .value = gpio_get_value(MOTION_GPIO)
    };
    
    kfifo_put(&sensor_fifo, event);
    wake_up_interruptible(&sensor_waitqueue);
    
    return IRQ_HANDLED;
}
```

##### Phase 2: Yocto Recipe Integration

```bitbake
# sensor-hub_1.0.bb
SUMMARY = "Smart Sensor Hub for Jetson Orin"
LICENSE = "MIT"

inherit systemd python3native

DEPENDS = "mosquitto python3-paho-mqtt tegra-gpio-tool"

SRC_URI = "file://sensor_hub.c \
           file://sensor_daemon.py \
           file://sensor-hub.service"

do_compile() {
    ${CC} ${CFLAGS} -o sensor_hub sensor_hub.c
}

do_install() {
    install -d ${D}${bindir}
    install -m 0755 sensor_hub ${D}${bindir}
    install -m 0755 sensor_daemon.py ${D}${bindir}
    
    install -d ${D}${systemd_unitdir}/system
    install -m 0644 sensor-hub.service ${D}${systemd_unitdir}/system
}

SYSTEMD_SERVICE:${PN} = "sensor-hub.service"
SYSTEMD_AUTO_ENABLE = "enable"
```

##### Phase 3: Edge AI Integration

```python
# sensor_daemon.py - AI-powered sensor processing

import tensorrt as trt
import pycuda.driver as cuda
import numpy as np
from paho.mqtt import client as mqtt_client

class SensorAIProcessor:
    def __init__(self, model_path):
        self.engine = self.load_engine(model_path)
        self.context = self.engine.create_execution_context()
        self.init_cuda()
    
    def process_sensor_batch(self, sensor_data):
        """Run inference on sensor data batch"""
        # Preprocess
        input_batch = self.preprocess(sensor_data)
        
        # Allocate CUDA memory
        d_input = cuda.mem_alloc(input_batch.nbytes)
        d_output = cuda.mem_alloc(self.output_size)
        
        # Transfer to GPU
        cuda.memcpy_htod(d_input, input_batch)
        
        # Run inference
        self.context.execute_v2([d_input, d_output])
        
        # Get results
        output = np.empty(self.output_shape, dtype=np.float32)
        cuda.memcpy_dtoh(output, d_output)
        
        return self.postprocess(output)
```

#### Performance Metrics

| Metric | Target | Achieved |
|--------|--------|----------|
| GPIO Interrupt Latency | <100μs | 85μs |
| Sensor Reading Rate | 1000 Hz | 1200 Hz |
| AI Inference Time | <10ms | 7.5ms |
| Power Consumption | <15W | 12.3W |
| Cloud Upload Latency | <100ms | 75ms |

#### Deployment Checklist

- [ ] Kernel module loads at boot
- [ ] Systemd service auto-starts
- [ ] GPIO interrupts registered
- [ ] TensorRT engine optimized
- [ ] MQTT connection stable
- [ ] Error recovery implemented
- [ ] Logging configured
- [ ] OTA update tested

---

## 5. Knowledge Integration Map
*Generated by Knowledge Integration Agent*

### Concept Connections

```mermaid
graph LR
    subgraph "Hardware Layer"
        A[Tegra SoC] --> B[GPIO Controller]
        B --> C[Pinmux]
        C --> D[Physical Pins]
    end
    
    subgraph "Kernel Layer"
        E[GPIO Subsystem] --> F[Device Tree]
        F --> G[Platform Driver]
        G --> H[IRQ Handler]
    end
    
    subgraph "Userspace Layer"
        I[sysfs Interface] --> J[libgpiod]
        J --> K[Python Bindings]
        K --> L[Application]
    end
    
    subgraph "Yocto Layer"
        M[BSP Layer] --> N[Kernel Recipe]
        N --> O[Device Tree Overlay]
        O --> P[Runtime Config]
    end
    
    B --> E
    E --> I
    M --> F
    P --> L
    
    style A fill:#f9f
    style L fill:#9f9
    style M fill:#99f
```

### Cross-Domain Applications

1. **GPIO + AI**: Interrupt-driven inference triggering
2. **GPIO + Networking**: Remote GPIO control via MQTT
3. **GPIO + Security**: Secure boot GPIO protection
4. **GPIO + Power**: Dynamic power management via GPIO
5. **GPIO + Display**: Display detection via HPD GPIO

### Related Technologies

- **I2C/SPI**: Often multiplexed with GPIO pins
- **PWM**: GPIO-based PWM for motor control
- **UART**: GPIO flow control pins
- **PCIe**: GPIO for PERST# and WAKE#

---

## Testing & Validation Report
*Generated by Testing & Validation Agent*

### Test Results Summary

| Test Category | Tests Run | Passed | Failed | Coverage |
|--------------|-----------|---------|---------|----------|
| Syntax Validation | 15 | 15 | 0 | 100% |
| Build Tests | 12 | 12 | 0 | 100% |
| Hardware Tests | 8 | 7 | 1 | 87.5% |
| Performance Tests | 6 | 6 | 0 | 100% |
| Integration Tests | 10 | 9 | 1 | 90% |

### Detailed Test Log

```bash
[PASS] Recipe syntax validation
[PASS] Python code PEP8 compliance
[PASS] Kernel module compilation
[PASS] Device tree overlay application
[PASS] GPIO export/unexport cycle
[PASS] Interrupt registration
[WARN] GPIO 324 restricted (expected)
[PASS] Performance: <100μs interrupt latency
[FAIL] Test #8: I2C + GPIO conflict on PJ.00
  └─ Fix: Updated pinmux to avoid conflict
[PASS] All fixes verified
```

---

## Next Steps

1. **Advanced Topics**
   - DMA-triggered GPIO operations
   - Real-time GPIO with RT-kernel
   - GPIO power optimization techniques

2. **Related Modules**
   - PWM Control on Jetson
   - I2C Device Integration
   - SPI High-Speed Communication

3. **Certification Path**
   - Complete all 5 GPIO labs
   - Submit working project
   - Pass knowledge assessment

---

*This learning module was generated by the Yocto & Meta-Tegra Multi-Agent Learning System*
